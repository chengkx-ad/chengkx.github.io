[{"title":"Build my first blog!","url":"/2024/03/27/Build-my-first-blog/","content":"Step1：安装Node.js和Git\nnode.js安装，在安装时会自动安装npm。\nGit安装，点击此处访问官网，按需下载对应版本，默认安装即可。\n检验安装是否成功：\nWin + R 打开运行窗口，输入cmd，输入如下命令，有相应版本信息显示则安装成功。\n若不正确可以卸载软件重新安装，此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行。\n\n\n\nStep2：安装并初始化配置Hexo\n在期望的位置新建一个文件夹，博客相关的内容都存在这个文件夹里。我这里直接在桌面新建了my_blog文件夹。\n\n在该文件夹下右键鼠标，点击Git Bash Here，输入以下npm命令\n  $ npm install hexo-cli -g  $ npm install hexo-deployer-git --save  \n\n在刚才新建的文件夹下再次新建一个Hexo文件夹，进入该Hexo文件夹右键，点击Git Bash Here，输入以下命令：hexo init，如下图：\n\n\nStep3：本地查看效果\n执行以下命令：hexo generate和hexo server\n\n而后可登录http://localhost:4000/，查看效果\n\n\nStep4：将博客部署到Github Pages上①创建项目代码库\n点击New repository创建代码项目库。\n注意！！项目名必须是：你的用户名.github.io！！！否则后续会连接不上以致404，谁试谁知道o(╥﹏╥)o\n\n②配置SSH密钥\n在你第一次新建的文件夹里面（my_blog） Git Bash Here输入以下命令：ssh-keygen -t rsa -C &quot;your email@example.com&quot; \n而后会出现Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):，这里直接回车将密钥按默认文件进行存储。\n而后会出现Enter passphrase (empty for no passphrase):  ，这里是让输入密码，确实没必要设置！！本人设置了123，后续还得动不动输入密码，且用下述方法删除了o(╥﹏╥)o。\n\n\n\n完整运行结果如下：\n\n运行以下命令，将公钥内容复制到系统粘贴板上： $ clip &lt; ~/.ssh/id_rsa.pub\n\n\n③在Github账户中添加公钥\n进入Settings\n\n\n找到SSH and GPG Keys\n\n\n选择New SSH key\n\n\n粘贴密钥\n\n\n\n④测试\n输入以下命令： $ ssh -T git@github.com，最后出现successfully即可。\n\n⑤配置Git个人信息$ git config --global user.name &quot;此处填你的用户名&quot;  $ git config --global user.email  &quot;此处填你的邮箱&quot;\n\n\n⑥将本地的Hexo文件更新到Github的库中\n粘贴SSH地址\n\n\n修改Hexo文件夹下的_config.yml文件\n\n\n在Hexo文件夹下的Git Bash Here下，先运行 npm install hexo-deployer-git --save\n\n然后输入hexo g -d，每次更新都要跑一下这个上传，第一次输入时，我这边是弹出了连接提示\n\n\n最后成功上传最后会显示如下提示：\n\n\n⑦访问博客\n上述都完成后，检验是否成功的方法是：从你的博客地址（https:&#x2F;&#x2F;你的用户名.github.io）访问，若出现如下画面即为连接成功。\n\nStep5：发表文章\n首先安装好图片插件，否则会出现图片不显示的问题。\n\n再次打开Hexo文件夹下的_config.yml，修改post_asset_folder: false为post_asset_folder: true。\n\n然后在Hexo文件夹下的Git Bash Here下，输入如下命令安装图片上传插件包npm install https://github.com/CodeFalling/hexo-asset-image --save\n\n而后，输入hexo n &quot;文件名&quot;，即可创建对应的md文件和用来放图片的文件夹（可在Hexo\\source\\posts里查看）。\n\n\n后续即编辑md内容（我默认用的typora编辑器），涉及到图片的地方，就用![](./Build-my-first-blog/1.png标准md图片引入语法。\n\n编辑好后，记得git跑一下hexo g -d上传更新。\n\n再次访问主页连接，即可看到最新更新的博客啦~\n\n\n\n\n参考博客\n使用 Github Pages 和 Hexo 搭建自己的独立博客\n解决hexo博文图片不显示的方法\n\n\n\n","categories":["博客搭建"],"tags":["Hexo"]},{"title":"Hello World","url":"/2024/03/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"右一的电子笔记全导航（持续更新ing","url":"/2024/04/18/%E5%8F%B3%E4%B8%80%E7%9A%84%E7%94%B5%E5%AD%90%E7%AC%94%E8%AE%B0%E5%85%A8%E5%AF%BC%E8%88%AA%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/","content":"\n⭐️【笔记涵盖】：数据结构、数据库、计算机网络、计算机组成原理、操作系统、图形学、大数据管理与分析、大数据安全、信息检索与数据挖掘、机器学习……\n⭐️该笔记导航主要对应【右一的电子笔记合集】专栏。整理不易，一点点有偿，持续更新，搭配笔记导航使用更佳(〃‘▽‘〃)\n⭐️其余实验过程记录及实操笔记不在笔记合集专栏内，但也在该导航作梳理，详情见对应公开专栏(ﾟ▽ﾟ*) 。\n\n📚计算机基础🐇高程（c++）\n高程 | 类与对象（c++）\n高程 | 数据的共享与保护（c++）\n高程 | 数组、指针与字符串（c++）\n高程 | 多态性（c++）\n高程 | 继承与派生（c++）\n\n🐇python基础\npython基础 | python基础语法\npython基础 | Numpy基础\npython基础 | Pandas基础\n\n🐇数据结构\n数据结构 | 第五章：线性表——数组描述 | arrayList的查找、插入、删除\n数据结构 | 第六章：线性表——链式描述 | 桶排序\n数据结构 | 第七章：数组和矩阵 | 行主映射和列主映射 | 稀疏矩阵\n数据结构 | 第八章：栈 | 数组描述arrayStack | 链表描述LinkedStack | 括号匹配\n数据结构 | 第九章：队列 | 循环队列 | 方法pop和push\n数据结构 | 第十章：散列表 | 字典 | 线性探查 | 链式散列 | LZW编码\n数据结构 | 第十一章：二叉树和其他树 | 【前序遍历】【中序遍历】【后序遍历】【层次遍历】 | 并查集\n数据结构 | 第十二章：优先级队列 | 堆 | 左高树 | 堆排序 | 霍夫曼编码\n数据结构 | 第十四章：搜索树 | 二叉搜索树的查找、插入、删除\n数据结构 | 第十五章：平衡搜索树——AVL树 | AVL树的搜索、插入、删除\n数据结构 | 第十五章：平衡搜索树——B-树 | B-树的搜索、插入、删除\n数据结构 | 第十六章：图 | 邻接矩阵 | 邻接链表 | 图的遍历【DFS】【BFS】\n数据结构 | 第十七章：贪婪算法 | 拓扑排序 | Dijkstra算法 | Kruskal算法 | Prim算法\n数据结构 | 第十八章：分而治之 | 归并排序 | 快速排序\n数据结构 | 第十九章：动态规划 | Floyd算法\n数据结构 | 各种排序算法梳理 | 复习版\n数据结构与算法 | 【题型】自制题目解析\n【转载】数据结构 | 时间与空间复杂度就看这篇了\n【转载】数据结构 | 【题型】霍夫曼编码：编码过程分析\n\n\n\n数据结构 | 线性表的顺序表示（王道）\n\n🐇数据库系统概念\n数据库系统概念 | 第一章 &amp;&amp; 第二章：引言 &amp;&amp; 关系模型\n数据库系统概念 | 第三章：SQL介绍\n数据库系统概念 | 第四章：中级SQL\n数据库系统概念 | 第六章：形式化关系查询语言 | 含带答案习题\n数据库系统概念 | 第七章：使用E-R模型的数据库设计 | ER图设计| ER图转化为关系模型 | 强实体和弱实体\n数据库系统概念 | 第十三章：事务管理 | 事务特性（ACID）| 冲突可串行化\n数据库系统概念 | 【应试向】SQL语句练习 &amp;&amp; 形式化关系查询语言\n\n🐇计算机网络\n计算机网络｜第一章：计算机网络和因特网\n计算机网络｜第二章：应用层\n计算机网络｜第三章：传输层\n计算机网络｜第四章：网络层：数据平面\n计算机网络｜第五章：网络层：控制平面\n计算机网络｜第六章：链路层和局域网\n\n🐇计算机组成原理\n计算机组成原理 | 第一章：概论 | 冯诺依曼计算机 | 计算机硬件\n计算机组成原理 | 第六章：计算机的运算方法 | 进制转换 | 定点运算 | 浮点数运算\n计算机组成原理 | 第四章：存储器 | 存储器与CPU连接 | 存储器的校验 | Cache容量计算\n计算机组成原理 | 第五章：输入输出系统 | 程序中断方式\n计算机组成原理 | 第八章：CPU结构和功能 | 中断屏蔽技术 | 指令周期\n计算机组成原理 | 第七章：指令系统 | 寻址方式 | 指令格式设计\n计算机组成原理 | 第九章：控制单元的功能 | 微操作命令 | 时钟周期\n计算机组成原理 | 第十章：控制单元的设计 | 节拍安排 | 微命令 | 微操作 | 微指令 | 微程序\n\n🐇操作系统\n操作系统 | 知识梳理 | 复习（上）\n操作系统｜知识梳理｜复习（下）\n操作系统 | 背诵梳理\n操作系统 | readline库的用处与安装方法\n\n📚大数据🐇大数据管理与分析\n大数据｜大数据基础（概念向）\n大数据｜Hadoop系统\n大数据｜HDFS分布式文件系统\n大数据｜MapReduce模型 | Hadoop MapReduce的基本工作原理\n大数据 | HBase基本工作原理\n大数据｜Hive和数据仓库\n大数据｜Spark介绍\n\n🐇大数据安全\n大数据安全 | 期末复习（上）\n大数据安全 | 期末复习（中）\n大数据安全 | 期末复习（下）\n\n🐇数据可视化\n可视化 | python可视化相关库梳理\n可视化 | 数据可视化降维算法梳理\n数据可视化 | 期末复习\n\n🐇机器学习\n机器学习｜机器学习概述\n机器学习 | 单变量线性回归 | 吴恩达学习笔记\n机器学习｜多变量线性回归 | 吴恩达学习笔记\n机器学习｜逻辑回归｜吴恩达学习笔记 | 牛顿法\n机器学习｜优化算法 | 评估方法｜分类模型性能评价指标 | 正则化\n机器学习 | 降维：PCA主成分分析\n机器学习 | SVD奇异值分解\n【转载】机器学习 | 降维：LDA\n机器学习 | 支持向量机SVM | 概念了解向\n机器学习 | 决策树 Decision Tree | 概念向\n机器学习 | 集成算法 | Bagging | Boosting | 概念向\n\n🐇信息检索与数据挖掘\n信息检索与数据挖掘 |（一）介绍\n信息检索与数据挖掘 | （二）布尔检索与倒排索引\n信息检索与数据挖掘 | （三）模糊检索\n信息检索与数据挖掘｜（四）索引构建\n信息检索与数据挖掘 | （五）文档评分、词项权重计算及向量空间模型\n【转载】信息检索与数据挖掘 | （六）信息检索度量指标\n信息检索与数据挖掘 | （七）概率检索模型\n信息检索与数据挖掘 | （八）语言建模的IR\n信息检索与数据挖掘 | （九）Link Analysis（链接分析）\n信息检索与数据挖掘 | （十）线性回归与逻辑回归\n信息检索与数据挖掘 | （十一）深度学习\n信息检索与数据挖掘 | （十二）聚类\n\n📚并行计算\n并行计算 | OpenMP初识 &amp;&amp; hello world小实验\n\n📚图形学\n图形学 | 期末复习（上）| games101笔记 | 补档\n图形学 | 期末复习（下）| games101笔记 | 补档\n\n👀大数据管理与分析【实验】\n大数据 | 实验零：安装Hadoop伪分布式系统\n大数据 | 实验一：大数据系统基本实验 | 常用的Linux操作和Hadoop系统\n大数据 | 实验一：大数据系统基本实验 | 熟悉常用的HDFS操作\n大数据 | 实验一：大数据基本实验 | MapReduce初级编程\n大数据 | 实验一：大数据基本实验 | 熟悉常用的HBase操作\n大数据 | 实验二：文档倒排索引算法实现\n大数据 | 实验三：PageRank算法实现\n大数据 | 实验四：并行化数据挖掘算法设计\n\n👀机器学习【实验】\n实验一：线性回归\n实验二：多变量线性回归\n实验三：逻辑回归和牛顿法\n实验四：正则化\n实验五：LDA\n\n👀大数据安全【实验】\n大数据安全 | 【实验】仿射加密\n大数据安全 | 【实验】凯撒加密与解密\n大数据安全 | 【实验】DES加密解密\n大数据安全 | 【实验】S-AES加密\n大数据安全 | 【实验】RSA加密解密\n大数据安全 | 【实验】Diffie-Hellman密钥交换算法\n大数据安全 | 【实验】ElGamal公钥密码\n\n👀数据可视化【图表】\n可视化 | echarts中国地图散点图\n可视化 | 3D文字球状标签云\n可视化 | echarts饼图改编\n可视化 | 基于CBDB的唐代历史人物分析\n可视化理论\n框架搭建\n关于iframe框架标签的实际应用\necharts条形折线复合图\necharts金字塔图\necharts中国地图热力图\necharts气泡图\necharts堆叠条形图&amp;多组条形图\n可视化大屏快速布局\nd3桑基图\nd3力导向关系图 \nd3力导向关系图优化（搜索+刷新）\n\n\n\n👀信息检索【实验】\n信息检索与数据挖掘 | 【实验】倒排索引与布尔查询\n信息检索与数据挖掘 | 【实验】排名检索模型\n信息检索与数据挖掘 | 【实验】检索评价指标MAP、MRR、NDCG\n\n👀爬虫【小实践】\n爬虫 | 基础模块了解\n爬虫 | 正则、Xpath、BeautifulSoup示例学习\n爬虫 | 【实践】Best Computer Science Scientists数据爬取\n爬虫 | 【实践】百度搜索链接爬取，生成标题词云 | 以“AI换脸”为例\n\n👀数据结构【实验】\n实验1.1 递归练习——子集价值\n实验1.2 递归练习——全排列问题\n实验2 排序算法\n实验3 数组描述线性表\n实验4.1 链表实现\n实验4.2 链表合并\n实验5 稀疏矩阵\n实验6 栈——算术表达式\n实验7 队列——卡片游戏\n实验8.1 线性开型寻址\n实验8.2 链表散列\n实验9.1 二叉树基础\n实验9.2 二叉树遍历\n实验10.1 堆的操作\n实验10.2 霍夫曼编码\n实验11 二叉搜索树（带索引）\n实验12 图论基础\n实验13 prim算法和kruskal算法\n\n👀前端【实操笔记】🐱核心技术\n前端｜HTML | pink老师\n前端｜CSS（一）| pink老师\n前端｜CSS（二）| pink老师\n前端｜项目实操流程｜学成在线项目实操 | pink老师\n【HTML4】（一）前端简介 \n【HTML4】（二）各种各样的常用标签\n【HTML4】（三）表单及HTML4收尾\n\n\n\n【CSS2】（四）CSS基础及CSS选择器\n【CSS2】（五）CSS三大特性及常用属性\n【CSS2】（六）CSS盒子模型\n【CSS2】（七）浮动\n【CSS2】（ 八）定位与布局\n【实操】（ 九）尚品汇实操练习\n【HTML5】（ 十）HTML5简介及相关新增属性\n【CSS3】（ 十一）CSS3简介及基本语法（上）| 相关新增属性\n【CSS3】（ 十二）CSS3简介及基本语法（中）| 变换、过渡与动画 \n【CSS3】 （十三）CSS3简介及基本语法（下）| 伸缩盒模型 \n【canvas】 | （十四）canvas基本用法 | 尚硅谷前端HTML5教程(html5入门经典)\n\n\n\nJavaScript |（一）JavaScript简介及基本语法\nJavaScript |（二）JavaScript自定义对象及函数\nJavaScript |（三）内建对象 | 数组 | string对象\nJavaScript |（四）正则表达式\nJavaScript |（五）DOM简介\nJavaScript |（六）DOM事件\nJavaScript |（七）BOM及JSON简介 | 轮播图\n\n🐱高级技术\nNode.js |（一）Node.js简介及计算机基础\nNode.js |（二）Node.js API：fs模块 | 尚硅谷2023版Node.js零基础视频教程\nNode.js |（三）Node.js API：path模块及Node.js 模块化 | 尚硅谷2023版Node.js零基础视频教程\nNode.js |（四）HTTP协议 | 尚硅谷2023版Node.js零基础视频教程\nNode.js |（五）包管理工具 | 尚硅谷2023版Node.js零基础视频教程\nNode.js |（六）express框架 | 尚硅谷2023版Node.js零基础视频教程\nNode.js |（七）express案例实践：记账本 | 尚硅谷2023版Node.js零基础视频教程\nES6 | （一）ES6 新特性（上） | 尚硅谷Web前端ES6教程\nES6 | （二）ES6 新特性（下） | 尚硅谷Web前端ES6教程\nVue | （一）Vue核心（上） | 尚硅谷Vue2.0+Vue3.0全套教程\nVue | （二）Vue核心（下） | 尚硅谷Vue2.0+Vue3.0全套教程\nVue | （三）Vue组件化编程 | 尚硅谷Vue2.0+Vue3.0全套教程\nVue | （四）使用Vue脚手架（上） | 尚硅谷Vue2.0+Vue3.0全套教程\nVue | （五）使用Vue脚手架（中）| 尚硅谷Vue2.0+Vue3.0全套教程\nVue | （六）使用Vue脚手架（下）| 尚硅谷Vue2.0+Vue3.0全套教程\n\n\n\nDjango初识\n\n🐱小案例\n一个带切换的登录注册界面\n喵喵大王立大功 | 一个带便利贴功能的todolist面板\n基于CBDB的唐代历史人物分析\nOpenShare | 前端三件套初识案例实践\n\n👀AIGC\nAI提示词构建\nAIGC工具库梳理（上）\nAIGC工具库梳理（下）\n\n👀杂货铺\n杂货铺 | Windows系统上解压缩tgz文件及环境配置一般步骤\n在Linux（Ubuntu）中使用终端编译 &amp;&amp; vscode安装\n杂货铺 | vscode配置C&#x2F;C++环境\n杂货铺 | 使用 Github Pages 和 Hexo 搭建自己的独立博客\nLinux虚拟机Ubuntu操作系统下设置共享文件夹\n杂货铺 | hexo自定义不使用主题模板渲染的独立页面\n\n"},{"title":"线性表的顺序表示","url":"/2024/04/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA/","content":"顺序表定义\n静态分配\n#define MaxSize 50typedef struct&#123;    ElemType data[MaxSize];    int length;&#125;SqList;\n\n动态分配\n#define InitSize 100typedef struct&#123;    ElemType *data;    int MaxSize,length;&#125;SeqList;\n\n综合应用\n从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。\n\n算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置，最后顺序表长度-1。\n\n代码\n  //删除顺序表L中最小元素结点，并通过引用型参数value返回其值bool Del_Min(SqList &amp;L,ElemType &amp;value)&#123;\tif(L.length==0)        return flase;    value=L.data[0];    int pos=0;    for(int i=1;i&lt;L.length;i++)    &#123;        if(L.data[i]&lt;value)        &#123;            value=L.data[i];            pos=i;        &#125;    &#125;    L.data[pos]=L.data[L.length-1];    L.length--;    return true;&#125;\n\n\n设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。\n\n算法思想：扫描顺序表L的前半部分元素，对于元素L.data[i]将其与后半部分的对应元素L.data[L.length-i-1]进行交换。\n\n代码\n  void Reverse(SqList &amp;L)&#123;    ElemType temp;    for(int i=0;i&lt;L.length/2;i++)    &#123;        temp=L.data[i];        L.data[i]=L.data[L.length-i-1];        L.data[L.length-i-1]=temp;    &#125;&#125;\n\n\n对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除顺序表中所有值为x的数据元素。\n\n算法思想：\n\n法①：用k记录顺序表L中不等于x的元素个数（即需要保存的元素个数），扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度。\n法②：用k记录顺序表L中等于x的元素个数，一遍扫描L，一遍统计k，并将不等于x的元素前移k个元素。扫描结束后修改L的长度。\n\n\n代码\n  void Del_x_1(SqList &amp;L,ElemType x)&#123;    int k=0;    for(int i=0;i&lt;L.length;i++)    &#123;        if(L.data[i]!=x)        &#123;            L.data[k]=L.data[i];            k++;        &#125;    &#125;    L.length=k;&#125;void Del_x_2(SqList &amp;L,ElemType x)&#123;    int k=0,i=0;    while(i&lt;L.length)    &#123;        if(L.data[i]==x)        \tk++;        else            L.data[i-k]=L.data[i];        i++;    &#125;    L.length=L.length-k;&#125;\n\n\n从顺序表中删除其值在给定值s和t之间（包含s和t，要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。\n\n算法思想：本题和第3题基本思路一样，只不过是判断条件不太一样。这里以法②思想为例。\n\n代码\nvoid Del_s_t(SqList &amp;L,ElemType s,ElemType t)&#123;    int k=0,i=0;    if(L.length==0||s&gt;=t)    \treturn false;    while(i&lt;L.length)    &#123;        if(L.data[i]&gt;=s&amp;&amp;L.data[i]&lt;=t)        \tk++;        else            L.data[i-k]=L.data[i];        i++;    &#125;    L.length=L.length-k;    return true;&#125;\n\n\n从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。\n\n算法思想：因为是有序顺序表，所以值相同的元素一定在连续的位置上。初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾。\n\n代码\nbool Delete_Same(SeqList &amp;L)&#123;    if(L.length==0)        return false;    int i,j;    for(i=0,j=1;j&lt;L.length;j++)    &#123;        if(L.data[i]!=L.data[j])            L.data[++i]=L.data[j];    &#125;    L.length=i+1;    return true;&#125;\n\n\n将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。\n\n算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看哪个表还有剩余，将剩下的部分加到新的顺序表后面。\n\n代码\nbool Merge(SeqList A,SeqList B,SeqList &amp;C)&#123;    if(A.length+B.length&gt;C.maxSize)        return false;    int i=0,j=0,k=0;    while(i&lt;A.length &amp;&amp; j&lt;B.length)    &#123;        if(A.data[i]&lt;=B.data[j])            C.data[k++]=A.data[i++];        else            C.data[k++]=B.data[j++];    &#125;    while(i&lt;A.length)        C.data[k++]=A.data[i++];    while(i&lt;B.length)        C.data[k++]=B.data[j++];    C.length=k;    return true;&#125;\n\n\n已知在一位数组A[m+n]中依次存放两个线性表a和b。编写一个函数，将数组中两个顺序表的位置互换。\n\n算法思想：首先将数组A[m+n]中的全部元素原地逆置，然后对前n个元素和后m个元素分别使用逆置算法，即可实现顺序表的位置互换\n\n代码\ntypedef int DataType;//逆转(aleft,aleft+1,aleft+2...,aright)为(aright,aright-1,...,aleft)void Reverse(DataType A[],int left,int right,int arraySize)&#123;\tif(left&gt;=right||right&gt;=arraySize)        return;    int mid=(left+right)/2;    for(int i=0;i&lt;=mid-left;i++)    &#123;        DataType temp=A[left+i];        A[left+i]=A[right-i];        A[right-i]=temp;    &#125;&#125;void Exchange(DataType A[],int m,int n,int arraySize)&#123;    Reverse(A,0,m+n-1,arraySize);    Reverse(A,0,n-1,arraySize);    Reverse(A,n,m+n-1,arraySize);&#125;\n\n说明：使用typedef关键字定义一个新的数据类型别名，如typedef int datatype;，可以将int类型起一个新名字datatype。这样做的好处有以下几点：\n\n提高代码可读性：使用有意义的别名，如datatype，而不是直接使用原始数据类型int，可以使代码更加清晰易懂。\n便于维护：如果将来需要改变数据类型，只需要修改typedef定义中的类型，而不需要在整个代码中搜索并替换所有的int为新的数据类型。\n简化声明：在使用结构体等复杂数据类型时，通过typedef定义别名，可以简化变量的声明，使得代码更加简洁。\n\n\n\n\n线性表a中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置交换，若找不到，则将其插入表中并使表中元素仍递增有序。\n\n算法思想：这里要求用最短的时间查找，于是采用折半查找。\n\n代码\nvoid SearchExchangeInsert(ElemType A[],ElemType x)&#123;    int low=0,high=n-1,mid;    //查找    while(low&lt;=high)    &#123;        mid=(low+high)/2;        if(A[mid]==x) break;        else if(A[mid]&lt;x) low=mid+1;        else high=mid-1;    &#125;    //交换    if(A[mid]==x&amp;&amp;mid!=n-1)    &#123;        t=A[mid];        A[mid]=A[mid+1];        A[mid+1]=t;    &#125;    //插入    if(low&gt;high)    &#123;        for(int i=n-1;i&gt;high;i--)             A[i+1]=A[i];        A[i+1]=x;    &#125;&#125;\n\n\n给定三个序列A、B、C，长度均为n，且均无重复元素的递增序列，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。\n\n算法思想：使用三个下标变量从小到大遍历数组。当三个下标变量指向的元素相等时，输出并向前推进指针，否则仅移动小于最大元素的下标变量，直到某个下标变量移出数组范围。\n\n代码\nvoid samekey(int A[],int B[],int C[],int n)&#123;    int i=0,j=0,k=0;    while(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n)    &#123;        if(A[i]==B[j]&amp;&amp;B[j]==C[k])        &#123;            printf(&quot;%d\\n&quot;,A[i]);            i++;            j++;            k++;        &#125;        else        &#123;            int maxNum=max(A[i],max(B[j],C[k]));            if(A[i]&lt;maxNum) i++;            if(B[j]&lt;maxNum) j++;            if(C[k]&lt;maxNum) k++;        &#125;    &#125;&#125;\n\n每个指针移动的次数不超过n次，且每次循环至少有一个指针后移，所以时间复杂度为O(n)；算法只用到了常数个变量，所以空间复杂度为O(1)。\n\n\n\n设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法，将R中保存的序列循环左移p(0&lt;p&lt;n)个位置。\n\n算法思想：本题可以看作第7题的变式。将问题视为把数组ab转换为数组ba(a代表数组的前p个元素，b代表数组中余下的n-p个元素)。例：abcdefgh向左循环移动3(p&#x3D;3)个位置，得到defghabc。\n\n代码：时间复杂度为O(n)；空间复杂度为O(1)。\ntypedef int DataType;//逆转(aleft,aleft+1,aleft+2...,aright)为(aright,aright-1,...,aleft)void Reverse(DataType A[],int left,int right)&#123;    int mid=(left+right)/2;    for(int i=0;i&lt;=mid-left;i++)    &#123;        DataType temp=A[left+i];        A[left+i]=A[right-i];        A[right-i]=temp;    &#125;&#125;void Exchange(DataType R[],int n,int p)&#123;    Reverse(R,0,n-1);    Reverse(R,0,p-1);    Reverse(R,p,n-1);&#125;\n\n\n一个长度为L(L≥1)的升序序列S，处在第L&#x2F;2个位置的数称为S的中位数。两个序列的中位数是包含它们所有元素的升序序列的中位数。现有两个等长升序序列S1和S2，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列S1和S2的中位数。\n\n算法思想：分别求两个升序序列A、B的中位数，设为a和b\n\n①若a&#x3D;b，则a或b即为所求中位数，算法结束。\n②若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等。\n③若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等。\n在保留的两个升序序列中，重复①②③，直至两个序列中均只包含一个元素，较小者即为所求。\n\n\n代码：时间复杂度为O(logn)；空间复杂度为O(1)。\nint M_Search(int A[],int B[],int n)&#123;    int s1,d1,m1,s2,d2,m2;    s1=0;    d1=n-1;    s2=0;    d2=n-1;    while(s1!=d1||s2!=d2)    &#123;        m1=(s1+d1)/2;        m2=(s2+d2)/2;        //条件(1)        if(A[m1]==B[m2])            return A[m1];        //条件(2)        if(A[m1]&lt;B[m2])        &#123;            if((s1+d1)%2==0)            &#123;                s1=m1;                d2=m2;            &#125;            else            &#123;                s1=m1+1;                d2=m2;            &#125;        &#125;        //条件(3)        else        &#123;            if((s1+d1)%2==0)            &#123;                d1=m1;                s2=m2;            &#125;            else            &#123;                d1=m1;                s2=m2+1;            &#125;        &#125;    &#125;    return A[s1]&lt;B[s2]?A[s1]:B[s2];&#125;\n\n\n已知一个整数序列A，长度为n，若存在大于n&#x2F;2个元素相等且等于x，则称x为A的主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。\n\n算法思想：从前向后扫描数组元素，标记出一个可能称为主元素的元素Num，然后重新计数，确认Num是否是主元素。\n\n①选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍为Num，则计数+1,否则计数-1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，直至扫描完全部数组元素。\n②判断c中元素是否是真正的主元素，再次扫描该数组，统计c中元素出现的次数，若大于n&#x2F;2，则为主元素。\n\n\n代码：时间复杂度为O(n)；空间复杂度为O(1)。\nint Majority(int A[],int n)&#123;    int c=A[0];    int count=1;    for(int i=0;i&lt;n;i++)    &#123;        if(A[i]==c)            count++;        else        &#123;            if(count&gt;0)                count--;            else&#123;                c=A[i];                count=1;            &#125;        &#125;    &#125;    if(count&gt;0)    &#123;        for(int i=count=0;i&lt;n;i++)        &#123;            if(A[i]==c)                count++;        &#125;    &#125;    if(count&gt;n/2)        return c;    else        return -1;&#125;\n\n对于统考算法题，花费大量时间去思考最优解是得不偿失的。\n\n\n\n给定一个含n(n≥1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。\n\n算法思想：分配一个用于标记的数组B[n]，从A[0]开始遍历A，若0&lt;A[i]&lt;=n，则令B[A[i]-1]=1;否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标i，返回i+1即为结果。若B[i]全部不为0，返回i+1(n+1)。\n\n代码：时间复杂度为O(n)；空间复杂度为O(n)。\nint FindMin(int A[],int n)&#123;    int *B;                        //标记数组    B=(int *)malloc(sizeof(int)*n);//分配空间    memset(B,0,sizeof(int)*n);     //赋初值为0    for(int i=0;i&lt;n;i++)    &#123;        if(A[i]&gt;0&amp;&amp;A[i]&lt;=n)            B[A[i]-1]=1;    &#125;    for(int i=0;i&lt;n;i++)    &#123;        if(B[i]==0) break;    &#125;    return i+1;&#125;\n\n\n定义三元组(a, b, c)（均为整数）的距离D&#x3D;|a-b|+|b-c|+|c-a|。给定3个非空整数集合A, B, C，按升序分别存储在3个数组里。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a, b, c)(a∈A, b∈B, c∈C)中的最小距离。\n\n算法思想：假设a≤b≤c，从数轴上看，D&#x3D;L1+L2+L3&#x3D;2*L3，即决定D大小的关键是a和c之间的距离。\n\n\n代码：时间复杂度为O(n)；空间复杂度为O(1)。\n#define INT_MAX 0x7fffffff//计算绝对值int abs_(int a)&#123;    if(a&lt;0) return -a;    else return a;&#125;//a是否是三个数中的最小值bool theMin(int a,int b,int c)&#123;    if(a&lt;=b&amp;&amp;a&lt;=c) return true;    return false;&#125;int findMin(int A[],int n,int B[],int m,int C[],int p)&#123;    int i=0, j=0, k=0, D_min=INT_MAX, D;    while(i&lt;n &amp;&amp; j&lt;m &amp;&amp; k&lt;p &amp;&amp; D_min&gt;0)    &#123;        D=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[I]);        if(D&lt;D_min) D_min=D;        if(theMin(A[i],B[j],C[k])) i++;        else if(theMin(B[j],C[k],A[i])) j++;        else k++;    &#125;    return D_min;&#125;\n\n\n\n","categories":["数据结构"],"tags":["线性表"]}]