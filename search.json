[{"title":"Build my first blog!","url":"/2024/03/27/Build-my-first-blog/","content":"Step1：安装Node.js和Git\nnode.js安装，在安装时会自动安装npm。\nGit安装，点击此处访问官网，按需下载对应版本，默认安装即可。\n检验安装是否成功：\nWin + R 打开运行窗口，输入cmd，输入如下命令，有相应版本信息显示则安装成功。\n若不正确可以卸载软件重新安装，此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行。\n\n\n\nStep2：安装并初始化配置Hexo\n在期望的位置新建一个文件夹，博客相关的内容都存在这个文件夹里。我这里直接在桌面新建了my_blog文件夹。\n\n在该文件夹下右键鼠标，点击Git Bash Here，输入以下npm命令\n  $ npm install hexo-cli -g  $ npm install hexo-deployer-git --save  \n\n在刚才新建的文件夹下再次新建一个Hexo文件夹，进入该Hexo文件夹右键，点击Git Bash Here，输入以下命令：hexo init，如下图：\n\n\nStep3：本地查看效果\n执行以下命令：hexo generate和hexo server\n\n而后可登录http://localhost:4000/，查看效果\n\n\nStep4：将博客部署到Github Pages上①创建项目代码库\n点击New repository创建代码项目库。\n注意！！项目名必须是：你的用户名.github.io！！！否则后续会连接不上以致404，谁试谁知道o(╥﹏╥)o\n\n②配置SSH密钥\n在你第一次新建的文件夹里面（my_blog） Git Bash Here输入以下命令：ssh-keygen -t rsa -C &quot;your email@example.com&quot; \n而后会出现Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):，这里直接回车将密钥按默认文件进行存储。\n而后会出现Enter passphrase (empty for no passphrase):  ，这里是让输入密码，确实没必要设置！！本人设置了123，后续还得动不动输入密码，且用下述方法删除了o(╥﹏╥)o。\n\n\n\n完整运行结果如下：\n\n运行以下命令，将公钥内容复制到系统粘贴板上： $ clip &lt; ~/.ssh/id_rsa.pub\n\n\n③在Github账户中添加公钥\n进入Settings\n\n\n找到SSH and GPG Keys\n\n\n选择New SSH key\n\n\n粘贴密钥\n\n\n\n④测试\n输入以下命令： $ ssh -T git@github.com，最后出现successfully即可。\n\n⑤配置Git个人信息$ git config --global user.name &quot;此处填你的用户名&quot;  $ git config --global user.email  &quot;此处填你的邮箱&quot;\n\n\n⑥将本地的Hexo文件更新到Github的库中\n粘贴SSH地址\n\n\n修改Hexo文件夹下的_config.yml文件\n\n\n在Hexo文件夹下的Git Bash Here下，先运行 npm install hexo-deployer-git --save\n\n然后输入hexo g -d，每次更新都要跑一下这个上传，第一次输入时，我这边是弹出了连接提示\n\n\n最后成功上传最后会显示如下提示：\n\n\n⑦访问博客\n上述都完成后，检验是否成功的方法是：从你的博客地址（https:&#x2F;&#x2F;你的用户名.github.io）访问，若出现如下画面即为连接成功。\n\nStep5：发表文章\n首先安装好图片插件，否则会出现图片不显示的问题。\n\n再次打开Hexo文件夹下的_config.yml，修改post_asset_folder: false为post_asset_folder: true。\n\n然后在Hexo文件夹下的Git Bash Here下，输入如下命令安装图片上传插件包npm install https://github.com/CodeFalling/hexo-asset-image --save\n\n而后，输入hexo n &quot;文件名&quot;，即可创建对应的md文件和用来放图片的文件夹（可在Hexo\\source\\posts里查看）。\n\n\n后续即编辑md内容（我默认用的typora编辑器），涉及到图片的地方，就用![](./Build-my-first-blog/1.png标准md图片引入语法。\n\n编辑好后，记得git跑一下hexo g -d上传更新。\n\n再次访问主页连接，即可看到最新更新的博客啦~\n\n\n\n\n参考博客\n使用 Github Pages 和 Hexo 搭建自己的独立博客\n解决hexo博文图片不显示的方法\n\n\n\n","categories":["博客搭建"],"tags":["Hexo"]},{"title":"Hello World","url":"/2024/03/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"线性表的顺序表示","url":"/2024/04/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA/","content":"\n从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。\n\n算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置，最后顺序表长度-1。\n\n代码\n  //删除顺序表L中最小元素结点，并通过引用型参数value返回其值bool Del_Min(SqList &amp;L,ElemType &amp;value)&#123;\tif(L.length==0)        return flase;    value=L.data[0];    int pos=0;    for(int i=1;i&lt;L.length;i++)    &#123;        if(L.data[i]&lt;value)        &#123;            value=L.data[i];            pos=i;        &#125;    &#125;    L.data[pos]=L.data[L.length-1];    L.length--;    return true;&#125;\n\n\n设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。\n\n算法思想：扫描顺序表L的前半部分元素，对于元素L.data[i]将其与后半部分的对应元素L.data[L.length-i-1]进行交换。\n\n代码\n  void Reverse(SqList &amp;L)&#123;    ElemType temp;    for(int i=0;i&lt;L.length/2;i++)    &#123;        temp=L.data[i];        L.data[i]=L.data[L.length-i-1];        L.data[L.length-i-1]=temp;    &#125;&#125;\n\n\n对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除顺序表中所有值为x的数据元素。\n\n算法思想：\n\n法①：用k记录顺序表L中不等于x的元素个数（即需要保存的元素个数），扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度。\n法②：用k记录顺序表L中等于x的元素个数，一遍扫描L，一遍统计k，并将不等于x的元素前移k个元素。扫描结束后修改L的长度。\n\n\n代码\n  void Del_x_1(SqList &amp;L,ElemType x)&#123;    int k=0;    for(int i=0;i&lt;L.length;i++)    &#123;        if(L.data[i]!=x)        &#123;            L.data[k]=L.data[i];            k++;        &#125;    &#125;    L.length=k;&#125;void Del_x_2(SqList &amp;L,ElemType x)&#123;    int k=0,i=0;    while(i&lt;L.length)    &#123;        if(L.data[i]==x)        \tk++;        else            L.data[i-k]=L.data[i];        i++;    &#125;    L.length=L.length-k;&#125;\n\n\n从顺序表中删除其值在给定值s和t之间（包含s和t，要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。\n\n算法思想：本题和第3题基本思路一样，只不过是判断条件不太一样。这里以法②思想为例。\n\n代码\nvoid Del_s_t(SqList &amp;L,ElemType s,ElemType t)&#123;    int k=0,i=0;    if(L.length==0||s&gt;=t)    \treturn false;    while(i&lt;L.length)    &#123;        if(L.data[i]&gt;=s&amp;&amp;L.data[i]&lt;=t)        \tk++;        else            L.data[i-k]=L.data[i];        i++;    &#125;    L.length=L.length-k;    return true;&#125;\n\n\n从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。\n\n算法思想：因为是有序顺序表，所以值相同的元素一定在连续的位置上。初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾。\n\n代码\nbool Delete_Same(SeqList &amp;L)&#123;    if(L.length==0)        return false;    int i,j;    for(i=0,j=1;j&lt;L.length;j++)    &#123;        if(L.data[i]!=L.data[j])            L.data[++i]=L.data[j];    &#125;    L.length=i+1;    return true;&#125;\n\n\n将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。\n\n已知在一位数组A[m+n]中依次存放两个线性表a和b。编写一个函数，将数组中两个顺序表的位置互换。\n\n线性表a中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置想交换，若找不到，则将其插入表中并使表中元素仍递增有序。\n\n给定三个序列A、B、C，长度均为n，且均无重复元素的递增序列，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。\n\n设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法，将R中保存的序列循环左移p(0&lt;p&lt;n)个位置。\n\n一个长度为L(L≥1)的升序序列S，处在第L&#x2F;2个位置的数称为S的中位数。两个序列的中位数是包含它们所有元素的升序序列的中位数。现有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。\n\n已知一个整数序列A，长度为n，若存在大于n&#x2F;2个元素相等且等于x，则称x为A的主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。\n\n给定一个含n(n≥1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。\n\n定义三元组(a, b, c)（均为整数）的距离D&#x3D;|a-b|+|b-c|+|c-a|。给定3个非空整数集合A, B, C，按升序分别存储在3个数组里。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a, b, c)(a∈A, b∈B, c∈C)中的最小距离。\n\n\n","categories":["数据结构"],"tags":["线性表"]}]