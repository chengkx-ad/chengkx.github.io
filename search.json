[{"title":"Hello World","url":"/2024/03/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Build my first blog!","url":"/2024/03/27/Build-my-first-blog/","content":"Step1：安装Node.js和Git\nnode.js安装，在安装时会自动安装npm。\nGit安装，点击此处访问官网，按需下载对应版本，默认安装即可。\n检验安装是否成功：\nWin + R 打开运行窗口，输入cmd，输入如下命令，有相应版本信息显示则安装成功。\n若不正确可以卸载软件重新安装，此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行。\n\n\n\nStep2：安装并初始化配置Hexo\n在期望的位置新建一个文件夹，博客相关的内容都存在这个文件夹里。我这里直接在桌面新建了my_blog文件夹。\n\n在该文件夹下右键鼠标，点击Git Bash Here，输入以下npm命令\n  $ npm install hexo-cli -g  $ npm install hexo-deployer-git --save  \n\n在刚才新建的文件夹下再次新建一个Hexo文件夹，进入该Hexo文件夹右键，点击Git Bash Here，输入以下命令：hexo init，如下图：\n\n\nStep3：本地查看效果\n执行以下命令：hexo generate和hexo server\n\n而后可登录http://localhost:4000/，查看效果\n\n\nStep4：将博客部署到Github Pages上①创建项目代码库\n点击New repository创建代码项目库。\n注意！！项目名必须是：你的用户名.github.io！！！否则后续会连接不上以致404，谁试谁知道o(╥﹏╥)o\n\n②配置SSH密钥\n在你第一次新建的文件夹里面（my_blog） Git Bash Here输入以下命令：ssh-keygen -t rsa -C &quot;your email@example.com&quot; \n而后会出现Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):，这里直接回车将密钥按默认文件进行存储。\n而后会出现Enter passphrase (empty for no passphrase):  ，这里是让输入密码，确实没必要设置！！本人设置了123，后续还得动不动输入密码，且用下述方法删除了o(╥﹏╥)o。\n\n\n\n完整运行结果如下：\n\n运行以下命令，将公钥内容复制到系统粘贴板上： $ clip &lt; ~/.ssh/id_rsa.pub\n\n\n③在Github账户中添加公钥\n进入Settings\n\n\n找到SSH and GPG Keys\n\n\n选择New SSH key\n\n\n粘贴密钥\n\n\n\n④测试\n输入以下命令： $ ssh -T git@github.com，最后出现successfully即可。\n\n⑤配置Git个人信息$ git config --global user.name &quot;此处填你的用户名&quot;  $ git config --global user.email  &quot;此处填你的邮箱&quot;\n\n\n⑥将本地的Hexo文件更新到Github的库中\n粘贴SSH地址\n\n\n修改Hexo文件夹下的_config.yml文件\n\n\n在Hexo文件夹下的Git Bash Here下，先运行 npm install hexo-deployer-git --save\n\n然后输入hexo g -d，每次更新都要跑一下这个上传，第一次输入时，我这边是弹出了连接提示\n\n\n最后成功上传最后会显示如下提示：\n\n\n⑦访问博客\n上述都完成后，检验是否成功的方法是：从你的博客地址（https:&#x2F;&#x2F;你的用户名.github.io）访问，若出现如下画面即为连接成功。\n\nStep5：发表文章\n首先安装好图片插件，否则会出现图片不显示的问题。\n\n再次打开Hexo文件夹下的_config.yml，修改post_asset_folder: false为post_asset_folder: true。\n\n然后在Hexo文件夹下的Git Bash Here下，输入如下命令安装图片上传插件包npm install https://github.com/CodeFalling/hexo-asset-image --save\n\n而后，输入hexo n &quot;文件名&quot;，即可创建对应的md文件和用来放图片的文件夹（可在Hexo\\source\\posts里查看）。\n\n\n后续即编辑md内容（我默认用的typora编辑器），涉及到图片的地方，就用![](./Build-my-first-blog/1.png标准md图片引入语法。\n\n编辑好后，记得git跑一下hexo g -d上传更新。\n\n再次访问主页连接，即可看到最新更新的博客啦~\n\n\n\n\n参考博客\n使用 Github Pages 和 Hexo 搭建自己的独立博客\n解决hexo博文图片不显示的方法\n\n\n\n","categories":["博客搭建"],"tags":["Hexo"]},{"title":"线性表的顺序表示","url":"/2024/04/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA/","content":"顺序表定义\n静态分配\n#define MaxSize 50typedef struct&#123;    ElemType data[MaxSize];    int length;&#125;SqList;\n\n动态分配\n#define InitSize 100typedef struct&#123;    ElemType *data;    int MaxSize,length;&#125;SeqList;\n\n综合应用\n从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。\n\n算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置，最后顺序表长度-1。\n\n代码\n  //删除顺序表L中最小元素结点，并通过引用型参数value返回其值bool Del_Min(SqList &amp;L,ElemType &amp;value)&#123;\tif(L.length==0)        return flase;    value=L.data[0];    int pos=0;    for(int i=1;i&lt;L.length;i++)    &#123;        if(L.data[i]&lt;value)        &#123;            value=L.data[i];            pos=i;        &#125;    &#125;    L.data[pos]=L.data[L.length-1];    L.length--;    return true;&#125;\n\n\n设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。\n\n算法思想：扫描顺序表L的前半部分元素，对于元素L.data[i]将其与后半部分的对应元素L.data[L.length-i-1]进行交换。\n\n代码\n  void Reverse(SqList &amp;L)&#123;    ElemType temp;    for(int i=0;i&lt;L.length/2;i++)    &#123;        temp=L.data[i];        L.data[i]=L.data[L.length-i-1];        L.data[L.length-i-1]=temp;    &#125;&#125;\n\n\n对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除顺序表中所有值为x的数据元素。\n\n算法思想：\n\n法①：用k记录顺序表L中不等于x的元素个数（即需要保存的元素个数），扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度。\n法②：用k记录顺序表L中等于x的元素个数，一遍扫描L，一遍统计k，并将不等于x的元素前移k个元素。扫描结束后修改L的长度。\n\n\n代码\n  void Del_x_1(SqList &amp;L,ElemType x)&#123;    int k=0;    for(int i=0;i&lt;L.length;i++)    &#123;        if(L.data[i]!=x)        &#123;            L.data[k]=L.data[i];            k++;        &#125;    &#125;    L.length=k;&#125;void Del_x_2(SqList &amp;L,ElemType x)&#123;    int k=0,i=0;    while(i&lt;L.length)    &#123;        if(L.data[i]==x)        \tk++;        else            L.data[i-k]=L.data[i];        i++;    &#125;    L.length=L.length-k;&#125;\n\n\n从顺序表中删除其值在给定值s和t之间（包含s和t，要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。\n\n算法思想：本题和第3题基本思路一样，只不过是判断条件不太一样。这里以法②思想为例。\n\n代码\nvoid Del_s_t(SqList &amp;L,ElemType s,ElemType t)&#123;    int k=0,i=0;    if(L.length==0||s&gt;=t)    \treturn false;    while(i&lt;L.length)    &#123;        if(L.data[i]&gt;=s&amp;&amp;L.data[i]&lt;=t)        \tk++;        else            L.data[i-k]=L.data[i];        i++;    &#125;    L.length=L.length-k;    return true;&#125;\n\n\n从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。\n\n算法思想：因为是有序顺序表，所以值相同的元素一定在连续的位置上。初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾。\n\n代码\nbool Delete_Same(SeqList &amp;L)&#123;    if(L.length==0)        return false;    int i,j;    for(i=0,j=1;j&lt;L.length;j++)    &#123;        if(L.data[i]!=L.data[j])            L.data[++i]=L.data[j];    &#125;    L.length=i+1;    return true;&#125;\n\n\n将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。\n\n算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看哪个表还有剩余，将剩下的部分加到新的顺序表后面。\n\n代码\nbool Merge(SeqList A,SeqList B,SeqList &amp;C)&#123;    if(A.length+B.length&gt;C.maxSize)        return false;    int i=0,j=0,k=0;    while(i&lt;A.length &amp;&amp; j&lt;B.length)    &#123;        if(A.data[i]&lt;=B.data[j])            C.data[k++]=A.data[i++];        else            C.data[k++]=B.data[j++];    &#125;    while(i&lt;A.length)        C.data[k++]=A.data[i++];    while(i&lt;B.length)        C.data[k++]=B.data[j++];    C.length=k;    return true;&#125;\n\n\n已知在一位数组A[m+n]中依次存放两个线性表a和b。编写一个函数，将数组中两个顺序表的位置互换。\n\n算法思想：首先将数组A[m+n]中的全部元素原地逆置，然后对前n个元素和后m个元素分别使用逆置算法，即可实现顺序表的位置互换\n\n代码\ntypedef int DataType;//逆转(aleft,aleft+1,aleft+2...,aright)为(aright,aright-1,...,aleft)void Reverse(DataType A[],int left,int right,int arraySize)&#123;\tif(left&gt;=right||right&gt;=arraySize)        return;    int mid=(left+right)/2;    for(int i=0;i&lt;=mid-left;i++)    &#123;        DataType temp=A[left+i];        A[left+i]=A[right-i];        A[right-i]=temp;    &#125;&#125;void Exchange(DataType A[],int m,int n,int arraySize)&#123;    Reverse(A,0,m+n-1,arraySize);    Reverse(A,0,n-1,arraySize);    Reverse(A,n,m+n-1,arraySize);&#125;\n\n说明：使用typedef关键字定义一个新的数据类型别名，如typedef int datatype;，可以将int类型起一个新名字datatype。这样做的好处有以下几点：\n\n提高代码可读性：使用有意义的别名，如datatype，而不是直接使用原始数据类型int，可以使代码更加清晰易懂。\n便于维护：如果将来需要改变数据类型，只需要修改typedef定义中的类型，而不需要在整个代码中搜索并替换所有的int为新的数据类型。\n简化声明：在使用结构体等复杂数据类型时，通过typedef定义别名，可以简化变量的声明，使得代码更加简洁。\n\n\n\n\n线性表a中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置交换，若找不到，则将其插入表中并使表中元素仍递增有序。\n\n算法思想：这里要求用最短的时间查找，于是采用折半查找。\n\n代码\nvoid SearchExchangeInsert(ElemType A[],ElemType x)&#123;    int low=0,high=n-1,mid;    //查找    while(low&lt;=high)    &#123;        mid=(low+high)/2;        if(A[mid]==x) break;        else if(A[mid]&lt;x) low=mid+1;        else high=mid-1;    &#125;    //交换    if(A[mid]==x&amp;&amp;mid!=n-1)    &#123;        t=A[mid];        A[mid]=A[mid+1];        A[mid+1]=t;    &#125;    //插入    if(low&gt;high)    &#123;        for(int i=n-1;i&gt;high;i--)             A[i+1]=A[i];        A[i+1]=x;    &#125;&#125;\n\n\n给定三个序列A、B、C，长度均为n，且均无重复元素的递增序列，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。\n\n算法思想：使用三个下标变量从小到大遍历数组。当三个下标变量指向的元素相等时，输出并向前推进指针，否则仅移动小于最大元素的下标变量，直到某个下标变量移出数组范围。\n\n代码\nvoid samekey(int A[],int B[],int C[],int n)&#123;    int i=0,j=0,k=0;    while(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n)    &#123;        if(A[i]==B[j]&amp;&amp;B[j]==C[k])        &#123;            printf(&quot;%d\\n&quot;,A[i]);            i++;            j++;            k++;        &#125;        else        &#123;            int maxNum=max(A[i],max(B[j],C[k]));            if(A[i]&lt;maxNum) i++;            if(B[j]&lt;maxNum) j++;            if(C[k]&lt;maxNum) k++;        &#125;    &#125;&#125;\n\n每个指针移动的次数不超过n次，且每次循环至少有一个指针后移，所以时间复杂度为O(n)；算法只用到了常数个变量，所以空间复杂度为O(1)。\n\n\n\n设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法，将R中保存的序列循环左移p(0&lt;p&lt;n)个位置。\n\n算法思想：本题可以看作第7题的变式。将问题视为把数组ab转换为数组ba(a代表数组的前p个元素，b代表数组中余下的n-p个元素)。例：abcdefgh向左循环移动3(p&#x3D;3)个位置，得到defghabc。\n\n代码：时间复杂度为O(n)；空间复杂度为O(1)。\ntypedef int DataType;//逆转(aleft,aleft+1,aleft+2...,aright)为(aright,aright-1,...,aleft)void Reverse(DataType A[],int left,int right)&#123;    int mid=(left+right)/2;    for(int i=0;i&lt;=mid-left;i++)    &#123;        DataType temp=A[left+i];        A[left+i]=A[right-i];        A[right-i]=temp;    &#125;&#125;void Exchange(DataType R[],int n,int p)&#123;    Reverse(R,0,n-1);    Reverse(R,0,p-1);    Reverse(R,p,n-1);&#125;\n\n\n一个长度为L(L≥1)的升序序列S，处在第L&#x2F;2个位置的数称为S的中位数。两个序列的中位数是包含它们所有元素的升序序列的中位数。现有两个等长升序序列S1和S2，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列S1和S2的中位数。\n\n算法思想：分别求两个升序序列A、B的中位数，设为a和b\n\n①若a&#x3D;b，则a或b即为所求中位数，算法结束。\n②若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等。\n③若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等。\n在保留的两个升序序列中，重复①②③，直至两个序列中均只包含一个元素，较小者即为所求。\n\n\n代码：时间复杂度为O(logn)；空间复杂度为O(1)。\nint M_Search(int A[],int B[],int n)&#123;    int s1,d1,m1,s2,d2,m2;    s1=0;    d1=n-1;    s2=0;    d2=n-1;    while(s1!=d1||s2!=d2)    &#123;        m1=(s1+d1)/2;        m2=(s2+d2)/2;        //条件(1)        if(A[m1]==B[m2])            return A[m1];        //条件(2)        if(A[m1]&lt;B[m2])        &#123;            if((s1+d1)%2==0)            &#123;                s1=m1;                d2=m2;            &#125;            else            &#123;                s1=m1+1;                d2=m2;            &#125;        &#125;        //条件(3)        else        &#123;            if((s1+d1)%2==0)            &#123;                d1=m1;                s2=m2;            &#125;            else            &#123;                d1=m1;                s2=m2+1;            &#125;        &#125;    &#125;    return A[s1]&lt;B[s2]?A[s1]:B[s2];&#125;\n\n\n已知一个整数序列A，长度为n，若存在大于n&#x2F;2个元素相等且等于x，则称x为A的主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。\n\n算法思想：从前向后扫描数组元素，标记出一个可能称为主元素的元素Num，然后重新计数，确认Num是否是主元素。\n\n①选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍为Num，则计数+1,否则计数-1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，直至扫描完全部数组元素。\n②判断c中元素是否是真正的主元素，再次扫描该数组，统计c中元素出现的次数，若大于n&#x2F;2，则为主元素。\n\n\n代码：时间复杂度为O(n)；空间复杂度为O(1)。\nint Majority(int A[],int n)&#123;    int c=A[0];    int count=1;    for(int i=0;i&lt;n;i++)    &#123;        if(A[i]==c)            count++;        else        &#123;            if(count&gt;0)                count--;            else&#123;                c=A[i];                count=1;            &#125;        &#125;    &#125;    if(count&gt;0)    &#123;        for(int i=count=0;i&lt;n;i++)        &#123;            if(A[i]==c)                count++;        &#125;    &#125;    if(count&gt;n/2)        return c;    else        return -1;&#125;\n\n对于统考算法题，花费大量时间去思考最优解是得不偿失的。\n\n\n\n给定一个含n(n≥1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。\n\n算法思想：分配一个用于标记的数组B[n]，从A[0]开始遍历A，若0&lt;A[i]&lt;=n，则令B[A[i]-1]=1;否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标i，返回i+1即为结果。若B[i]全部不为0，返回i+1(n+1)。\n\n代码：时间复杂度为O(n)；空间复杂度为O(n)。\nint FindMin(int A[],int n)&#123;    int *B;                        //标记数组    B=(int *)malloc(sizeof(int)*n);//分配空间    memset(B,0,sizeof(int)*n);     //赋初值为0    for(int i=0;i&lt;n;i++)    &#123;        if(A[i]&gt;0&amp;&amp;A[i]&lt;=n)            B[A[i]-1]=1;    &#125;    for(int i=0;i&lt;n;i++)    &#123;        if(B[i]==0) break;    &#125;    return i+1;&#125;\n\n\n定义三元组(a, b, c)（均为整数）的距离D&#x3D;|a-b|+|b-c|+|c-a|。给定3个非空整数集合A, B, C，按升序分别存储在3个数组里。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a, b, c)(a∈A, b∈B, c∈C)中的最小距离。\n\n算法思想：假设a≤b≤c，从数轴上看，D&#x3D;L1+L2+L3&#x3D;2*L3，即决定D大小的关键是a和c之间的距离。\n\n\n代码：时间复杂度为O(n)；空间复杂度为O(1)。\n#define INT_MAX 0x7fffffff//计算绝对值int abs_(int a)&#123;    if(a&lt;0) return -a;    else return a;&#125;//a是否是三个数中的最小值bool theMin(int a,int b,int c)&#123;    if(a&lt;=b&amp;&amp;a&lt;=c) return true;    return false;&#125;int findMin(int A[],int n,int B[],int m,int C[],int p)&#123;    int i=0, j=0, k=0, D_min=INT_MAX, D;    while(i&lt;n &amp;&amp; j&lt;m &amp;&amp; k&lt;p &amp;&amp; D_min&gt;0)    &#123;        D=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[I]);        if(D&lt;D_min) D_min=D;        if(theMin(A[i],B[j],C[k])) i++;        else if(theMin(B[j],C[k],A[i])) j++;        else k++;    &#125;    return D_min;&#125;\n\n\n\n","categories":["数据结构"],"tags":["线性表"]}]